"use strict";(globalThis.webpackChunkai_systems_book=globalThis.webpackChunkai_systems_book||[]).push([[744],{26:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"module1/chapter3-services-actions","title":"ROS 2 Services and Actions - Request-Response Communication","description":"Introduction (300 words)","source":"@site/docs/module1/chapter3-services-actions.md","sourceDirName":"module1","slug":"/module1/chapter3-services-actions","permalink":"/ai-system-book/module1/chapter3-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedaAnabia/ai-systems-book/docs/module1/chapter3-services-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Understanding ROS 2 Nodes","permalink":"/ai-system-book/module1/chapter2-nodes-topics-services"},"next":{"title":"ROS 2 Parameters and Launch Files - Configuration and Orchestration","permalink":"/ai-system-book/module1/chapter4-params-launch"}}');var t=r(4848),i=r(8453);const a={},o="ROS 2 Services and Actions - Request-Response Communication",c={},l=[{value:"Introduction (300 words)",id:"introduction-300-words",level:2},{value:"Section 1: Understanding ROS 2 Services (800 words)",id:"section-1-understanding-ros-2-services-800-words",level:2},{value:"Service Architecture: Client-Server Model",id:"service-architecture-client-server-model",level:3},{value:"Service vs Topic Comparison",id:"service-vs-topic-comparison",level:3},{value:"When to Use Services",id:"when-to-use-services",level:3},{value:"Built-in ROS 2 Services Examples",id:"built-in-ros-2-services-examples",level:3},{value:"Real-world Humanoid Robotics Examples",id:"real-world-humanoid-robotics-examples",level:3},{value:"Section 2: Creating Service Servers and Clients (1000 words)",id:"section-2-creating-service-servers-and-clients-1000-words",level:2},{value:"Part A: Service Interfaces",id:"part-a-service-interfaces",level:3},{value:"Part B: Creating a Service Server",id:"part-b-creating-a-service-server",level:3},{value:"Part C: Creating a Service Client",id:"part-c-creating-a-service-client",level:3},{value:"Section 3: Understanding ROS 2 Actions (800 words)",id:"section-3-understanding-ros-2-actions-800-words",level:2},{value:"What Are Actions?",id:"what-are-actions",level:3},{value:"Action State Machine",id:"action-state-machine",level:3},{value:"When to Use Actions",id:"when-to-use-actions",level:3},{value:"Action vs Service vs Topic Comparison",id:"action-vs-service-vs-topic-comparison",level:3},{value:"Real-world Humanoid Robotics Examples",id:"real-world-humanoid-robotics-examples-1",level:3},{value:"Action Architecture",id:"action-architecture",level:3},{value:"Section 4: Creating Action Servers and Clients (1000 words)",id:"section-4-creating-action-servers-and-clients-1000-words",level:2},{value:"Part A: Action Interfaces",id:"part-a-action-interfaces",level:3},{value:"Part B: Creating an Action Server",id:"part-b-creating-an-action-server",level:3},{value:"Part C: Creating an Action Client",id:"part-c-creating-an-action-client",level:3},{value:"Section 5: Practical Comparison and Use Cases (600 words)",id:"section-5-practical-comparison-and-use-cases-600-words",level:2},{value:"Decision Framework for Communication Patterns",id:"decision-framework-for-communication-patterns",level:3},{value:"Comprehensive Comparison",id:"comprehensive-comparison",level:3},{value:"Real-World Robotics Use Cases",id:"real-world-robotics-use-cases",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Integration Patterns",id:"integration-patterns",level:3},{value:"Summary and Next Steps (200 words)",id:"summary-and-next-steps-200-words",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ros-2-services-and-actions---request-response-communication",children:"ROS 2 Services and Actions - Request-Response Communication"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction-300-words",children:"Introduction (300 words)"}),"\n",(0,t.jsx)(n.p,{children:"Imagine a humanoid robot performing a complex task in an industrial setting. The robot's control system needs to make a critical decision: Is the environment safe for the next maneuver? Rather than continuously publishing sensor data (like topics would), the robot needs an immediate answer to this specific query. This is precisely where ROS 2 services come into play\u2014they allow nodes to request specific information and receive immediate responses, enabling critical decision-making in robotics applications."}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we delve deep into the synchronous communication patterns of ROS 2: services and actions. You'll learn how services facilitate request-response interactions and how actions manage long-running tasks with feedback. These communication patterns complement the publish-subscribe model you learned in Chapter 2, expanding your toolkit for building sophisticated robotic systems."}),"\n",(0,t.jsx)(n.p,{children:"Understanding services and actions is fundamental to mastering ROS 2's communication architecture. Unlike topics, which provide asynchronous, one-way data flow, services enable synchronous, two-way communication where a client sends a request and awaits a specific response. Actions elevate this concept further by managing complex, long-duration tasks with ongoing feedback and the ability to cancel operations mid-execution\u2014essential for humanoid robotics tasks like walking, manipulation, or navigation."}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you'll be able to implement service-based communication for on-demand queries and action-based systems for complex robot behaviors. You'll understand when to use topics, services, or actions, and how to create custom interfaces for your specific robotics applications. The chapter includes practical examples focused on humanoid robot applications, detailed code examples with clear explanations, and exercises that reinforce your learning. We'll explore real-world use cases that demonstrate how services and actions enable robots to interact intelligently with their environment and make timely decisions."}),"\n",(0,t.jsx)(n.h2,{id:"section-1-understanding-ros-2-services-800-words",children:"Section 1: Understanding ROS 2 Services (800 words)"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 services implement a synchronous client-server communication pattern where one node (the service client) sends a request to another node (the service server) and waits for a response. This request-response paradigm is fundamentally different from the asynchronous publish-subscribe model you've already learned about. Services provide a direct method for nodes to request specific computation or information, making them ideal for operations that require immediate results or acknowledgments."}),"\n",(0,t.jsx)(n.h3,{id:"service-architecture-client-server-model",children:"Service Architecture: Client-Server Model"}),"\n",(0,t.jsx)(n.p,{children:"The service architecture in ROS 2 follows a traditional client-server model. A service server node offers a specific service by registering with the ROS graph under a unique service name. Multiple service client nodes can then connect to this service server to make requests. The key distinction is that the service client blocks execution until it receives a response from the server, creating a synchronous interaction."}),"\n",(0,t.jsxs)(n.p,{children:["The service interface is defined using ",(0,t.jsx)(n.code,{children:".srv"})," files, which specify two components: the request message format and the response message format. The request contains the parameters sent by the client to the server, while the response contains the computed result or status sent back from the server to the client. This structured format ensures that both clients and servers agree on the data format for communication."]}),"\n",(0,t.jsx)(n.h3,{id:"service-vs-topic-comparison",children:"Service vs Topic Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Topics"}),(0,t.jsx)(n.th,{children:"Services"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Communication Pattern"}),(0,t.jsx)(n.td,{children:"Publish-Subscribe"}),(0,t.jsx)(n.td,{children:"Request-Response"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Synchronicity"}),(0,t.jsx)(n.td,{children:"Asynchronous"}),(0,t.jsx)(n.td,{children:"Synchronous"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Data Direction"}),(0,t.jsx)(n.td,{children:"One-way (publisher \u2192 subscriber)"}),(0,t.jsx)(n.td,{children:"Two-way (client \u2194 server)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Blocking"}),(0,t.jsx)(n.td,{children:"No - non-blocking"}),(0,t.jsx)(n.td,{children:"Yes - client waits for response"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Use Case"}),(0,t.jsx)(n.td,{children:"Streaming data, sensor feeds"}),(0,t.jsx)(n.td,{children:"Configuration, queries, commands"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Guaranteed Delivery"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Performance"}),(0,t.jsx)(n.td,{children:"High-frequency, low-latency"}),(0,t.jsx)(n.td,{children:"Lower frequency, higher latency"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-services",children:"When to Use Services"}),"\n",(0,t.jsx)(n.p,{children:"Services are ideal for scenarios demanding immediate responses:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configuration queries"}),": Getting robot parameters, updating settings, or changing operational modes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State queries"}),": Requesting current robot status, battery level, or sensor calibration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mode switching"}),": Changing robot operational states (idle, active, maintenance)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Short-duration tasks"}),": Calculations or operations that complete quickly without intermediate feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"built-in-ros-2-services-examples",children:"Built-in ROS 2 Services Examples"}),"\n",(0,t.jsxs)(n.p,{children:["ROS 2 provides several standard services through packages like ",(0,t.jsx)(n.code,{children:"std_srvs"})," and ",(0,t.jsx)(n.code,{children:"example_interfaces"}),". For instance, the ",(0,t.jsx)(n.code,{children:"SetBool"})," service allows toggling a Boolean state, while ",(0,t.jsx)(n.code,{children:"Trigger"})," enables activating specific actions with success/error responses. These serve as excellent templates for custom service design."]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-humanoid-robotics-examples",children:"Real-world Humanoid Robotics Examples"}),"\n",(0,t.jsx)(n.p,{children:"Consider these practical examples in humanoid robotics:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Get robot joint positions"}),": A client requests current joint angles for posture analysis"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set operating mode"}),': A client sends a request to switch the robot from "navigation" to "manipulation" mode']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Emergency stop trigger"}),": A safety module sends an immediate request to halt all robot motion"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Services ensure these critical operations receive immediate attention and confirmation, which is impossible with the fire-and-forget nature of topics."}),"\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Warning"}),": Misusing services for high-frequency data transmission can lead to performance bottlenecks since each request blocks the client until receiving a response. Use topics for continuous data streams."]}),"\n",(0,t.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,t.jsx)(n.strong,{children:"Pro Tip"}),": Services are perfect for implementing RPC-style (Remote Procedure Call) interfaces where you need guaranteed delivery and immediate confirmation of operations."]}),"\n",(0,t.jsx)(n.h2,{id:"section-2-creating-service-servers-and-clients-1000-words",children:"Section 2: Creating Service Servers and Clients (1000 words)"}),"\n",(0,t.jsx)(n.h3,{id:"part-a-service-interfaces",children:"Part A: Service Interfaces"}),"\n",(0,t.jsxs)(n.p,{children:["Service interfaces in ROS 2 are defined by ",(0,t.jsx)(n.code,{children:".srv"})," files that specify both the request and response message structures. These files follow a specific format where the request fields are listed first (before the ",(0,t.jsx)(n.code,{children:"---"})," separator), followed by the response fields. Standard service types are available in packages like ",(0,t.jsx)(n.code,{children:"std_srvs"})," and ",(0,t.jsx)(n.code,{children:"example_interfaces"}),", but custom services are essential for specialized robotics applications."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, let's create a custom service definition ",(0,t.jsx)(n.code,{children:"CalculateTrajectory.srv"})," to handle trajectory calculation requests for humanoid robot arms:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# Request fields for calculating a trajectory\r\nfloat64 start_position\r\nfloat64 end_position\r\nfloat64 duration\r\n---\r\n# Response fields containing the trajectory\r\nbool success\r\nstring message\r\nfloat64[] positions\r\nfloat64[] velocities\n"})}),"\n",(0,t.jsx)(n.p,{children:"This definition specifies that clients will send start/end positions and duration, and the server will respond with success status, a message, and arrays of positions and velocities for the trajectory."}),"\n",(0,t.jsx)(n.p,{children:"Standard service types include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SetBool"}),": Toggle a Boolean value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Trigger"}),": Perform an action with success/failure response"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Empty"}),": A service with no request/response data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"example_interfaces/srv/AddTwoInts"}),": Add two integers and return the result"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Custom service definition syntax requires:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Request fields listed before the ",(0,t.jsx)(n.code,{children:"---"})," separator"]}),"\n",(0,t.jsx)(n.li,{children:"Response fields listed after the separator"}),"\n",(0,t.jsx)(n.li,{children:"Standard ROS message types (int32, float64, string, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Descriptive field names following ROS naming conventions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"part-b-creating-a-service-server",children:"Part B: Creating a Service Server"}),"\n",(0,t.jsxs)(n.p,{children:["To create a service server, you inherit from the Node class and implement a service using the ",(0,t.jsx)(n.code,{children:"create_service"})," method. Here's a detailed example of implementing the CalculateTrajectory service:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\r\nfrom rclpy.duration import Duration\r\nimport numpy as np\r\nfrom builtin_interfaces.msg import Duration as DurationMsg\r\nimport rclpy\r\n\r\n# Assuming we have our custom message type\r\n# This would be generated from our .srv file\r\nfrom trajectory_msgs.srv import CalculateTrajectory\r\n\r\n\r\nclass TrajectoryCalculationServer(Node):\r\n    def __init__(self):\r\n        super().__init__('trajectory_calculation_server')\r\n        \r\n        # Create the service server\r\n        self.service = self.create_service(\r\n            CalculateTrajectory,\r\n            'calculate_trajectory',\r\n            self.calculate_trajectory_callback\r\n        )\r\n        \r\n        self.get_logger().info('Trajectory calculation service is ready.')\r\n\r\n    def calculate_trajectory_callback(self, request, response):\r\n        \"\"\"\r\n        Callback function that processes the trajectory calculation request.\r\n        \r\n        Args:\r\n            request: The incoming request with start_position, end_position, and duration\r\n            response: The response object to be populated with results\r\n            \r\n        Returns:\r\n            response: The filled response object with trajectory data\r\n        \"\"\"\r\n        self.get_logger().info(\r\n            f'Received trajectory request: start={request.start_position}, '\r\n            f'end={request.end_position}, duration={request.duration}'\r\n        )\r\n        \r\n        # Validate inputs\r\n        if request.duration <= 0.0:\r\n            response.success = False\r\n            response.message = 'Duration must be positive'\r\n            return response\r\n        \r\n        if abs(request.start_position - request.end_position) < 0.001:\r\n            response.success = False\r\n            response.message = 'Start and end positions are too close'\r\n            return response\r\n\r\n        # Calculate trajectory using a simple linear interpolation\r\n        # with trapezoidal velocity profile (constant acceleration phase)\r\n        num_points = 50  # Number of discrete trajectory points\r\n        dt = request.duration / (num_points - 1)  # Time step\r\n        \r\n        # Generate time steps\r\n        t_steps = np.linspace(0, request.duration, num_points)\r\n        \r\n        # Generate positions with linear interpolation\r\n        positions = []\r\n        velocities = []\r\n        \r\n        # Simple linear trajectory - in practice, this would use more complex motion planning\r\n        for t in t_steps:\r\n            # Linear interpolation between start and end positions\r\n            ratio = t / request.duration\r\n            pos = request.start_position + ratio * (request.end_position - request.start_position)\r\n            \r\n            # Constant velocity (in practice, would be a smooth profile)\r\n            vel = (request.end_position - request.start_position) / request.duration\r\n            \r\n            positions.append(float(pos))\r\n            velocities.append(float(vel))\r\n        \r\n        # Populate response\r\n        response.success = True\r\n        response.message = 'Trajectory calculated successfully'\r\n        response.positions = positions\r\n        response.velocities = velocities\r\n        \r\n        self.get_logger().info(\r\n            f'Trajectory calculation completed: {len(positions)} points generated'\r\n        )\r\n        \r\n        return response\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    trajectory_server = TrajectoryCalculationServer()\r\n    \r\n    try:\r\n        rclpy.spin(trajectory_server)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        trajectory_server.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This server demonstrates key aspects of service implementation: input validation, processing logic, and response population. The service server registers the ",(0,t.jsx)(n.code,{children:"calculate_trajectory"})," service name, which clients can use to make requests. The callback function processes each request and returns an appropriate response."]}),"\n",(0,t.jsx)(n.h3,{id:"part-c-creating-a-service-client",children:"Part C: Creating a Service Client"}),"\n",(0,t.jsx)(n.p,{children:"Service clients initiate requests to service servers and await responses. Here's an example client for the trajectory calculation service:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom trajectory_msgs.srv import CalculateTrajectory\r\n\r\n\r\nclass TrajectoryClient(Node):\r\n    def __init__(self):\r\n        super().__init__('trajectory_client')\r\n        \r\n        # Create a client for the trajectory service\r\n        self.cli = self.create_client(CalculateTrajectory, 'calculate_trajectory')\r\n        \r\n        # Wait for the service to be available\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('Waiting for trajectory service...')\r\n        \r\n        self.req = CalculateTrajectory.Request()\r\n\r\n    def send_request(self, start_pos, end_pos, duration):\r\n        \"\"\"\r\n        Send a request to calculate a trajectory.\r\n        \r\n        Args:\r\n            start_pos: Starting position for the trajectory\r\n            end_pos: Ending position for the trajectory\r\n            duration: Time duration for the trajectory execution\r\n            \r\n        Returns:\r\n            Future object that will hold the response\r\n        \"\"\"\r\n        self.req.start_position = start_pos\r\n        self.req.end_position = end_pos\r\n        self.req.duration = duration\r\n        \r\n        self.get_logger().info(\r\n            f'Sending trajectory request: start={start_pos}, '\r\n            f'end={end_pos}, duration={duration}'\r\n        )\r\n        \r\n        # Asynchronously call the service\r\n        future = self.cli.call_async(self.req)\r\n        return future\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    trajectory_client = TrajectoryClient()\r\n    \r\n    # Send a request for trajectory calculation\r\n    start_pos = 0.0\r\n    end_pos = 1.5\r\n    duration = 2.0\r\n    \r\n    future = trajectory_client.send_request(start_pos, end_pos, duration)\r\n    \r\n    try:\r\n        # Wait for the response (blocking until response arrives)\r\n        rclpy.spin_until_future_complete(trajectory_client, future)\r\n        \r\n        if future.result() is not None:\r\n            response = future.result()\r\n            \r\n            if response.success:\r\n                trajectory_client.get_logger().info(\r\n                    f'Trajectory calculated successfully!'\r\n                    f'Message: {response.message}'\r\n                    f'Number of points: {len(response.positions)}'\r\n                )\r\n                \r\n                # Print the first few trajectory points\r\n                for i in range(min(5, len(response.positions))):\r\n                    pos = response.positions[i]\r\n                    vel = response.velocities[i]\r\n                    trajectory_client.get_logger().info(\r\n                        f'Point {i}: Position={pos:.3f}, Velocity={vel:.3f}'\r\n                    )\r\n                    \r\n                if len(response.positions) > 5:\r\n                    trajectory_client.get_logger().info('...')\r\n            else:\r\n                trajectory_client.get_logger().error(\r\n                    f'Trajectory calculation failed: {response.message}'\r\n                )\r\n        else:\r\n            trajectory_client.get_logger().error(\r\n                f'Exception while calling service: {future.exception()}'\r\n            )\r\n    \r\n    except KeyboardInterrupt:\r\n        trajectory_client.get_logger().info('Interrupted during service call')\r\n    finally:\r\n        trajectory_client.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This client demonstrates how to create a service client, wait for the service to be available, send a request, and handle the response. Notice the synchronous nature - the ",(0,t.jsx)(n.code,{children:"spin_until_future_complete"})," call blocks until the response is received."]}),"\n",(0,t.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,t.jsx)(n.strong,{children:"Pro Tip"}),": Use timeouts when calling services to avoid indefinite blocking if the service server becomes unavailable."]}),"\n",(0,t.jsx)(n.h2,{id:"section-3-understanding-ros-2-actions-800-words",children:"Section 3: Understanding ROS 2 Actions (800 words)"}),"\n",(0,t.jsx)(n.p,{children:"While services perfectly handle simple request-response interactions, humanoid robotics and other complex robotic applications often require managing long-running tasks with intermediate feedback. This is where ROS 2 actions excel. Actions provide a communication pattern specifically designed for operations that take significant time to complete, allowing clients to monitor progress, receive continuous feedback, and even cancel tasks if needed."}),"\n",(0,t.jsx)(n.h3,{id:"what-are-actions",children:"What Are Actions?"}),"\n",(0,t.jsx)(n.p,{children:"An action is a communication pattern that extends the service model to support long-running, goal-oriented tasks. Unlike services, which provide an immediate response to a request, actions enable nodes to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Send a goal to initiate a long-running task"}),"\n",(0,t.jsx)(n.li,{children:"Receive continuous feedback during execution"}),"\n",(0,t.jsx)(n.li,{children:"Get a final result when the task completes"}),"\n",(0,t.jsx)(n.li,{children:"Cancel or preempt the task before completion"}),"\n",(0,t.jsx)(n.li,{children:"Track the current state of the task"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The action interface consists of three message types encapsulated in a single ",(0,t.jsx)(n.code,{children:".action"})," file:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": Defines the goal request sent to the action server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Defines the intermediate feedback messages during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": Defines the final result returned upon completion"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"action-state-machine",children:"Action State Machine"}),"\n",(0,t.jsx)(n.p,{children:"Each action follows a well-defined state machine that tracks the lifecycle of the goal:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PENDING"}),": Goal accepted but not yet processed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ACTIVE"}),": Goal is being processed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PREEMPTED"}),": Goal was cancelled before completion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SUCCEEDED"}),": Goal completed successfully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ABORTED"}),": Goal failed to complete due to an error"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RECALLING"}),": Goal is being recalled"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"REJECTED"}),": Goal was rejected and never processed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LOST"}),": Connection to the action server was lost"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The action client can monitor state transitions throughout the execution of the goal, enabling sophisticated interaction patterns."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-actions",children:"When to Use Actions"}),"\n",(0,t.jsx)(n.p,{children:"Actions are ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation tasks"}),": Moving a robot to a specific location with path feedback"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Manipulation tasks"}),": Controlling robot arms with joint position feedback"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Calibration processes"}),": Long-running sensor calibration with progress updates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data processing"}),": Computational tasks with progress feedback"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complex behaviors"}),": Multi-step robot behaviors requiring monitoring"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"action-vs-service-vs-topic-comparison",children:"Action vs Service vs Topic Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Pattern"}),(0,t.jsx)(n.th,{children:"Communication"}),(0,t.jsx)(n.th,{children:"Latency"}),(0,t.jsx)(n.th,{children:"Feedback"}),(0,t.jsx)(n.th,{children:"Cancellation"}),(0,t.jsx)(n.th,{children:"Best For"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Topics"}),(0,t.jsx)(n.td,{children:"Continuous stream"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Sensor data, status"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Services"}),(0,t.jsx)(n.td,{children:"Request-Response"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Configuration, queries"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Actions"}),(0,t.jsx)(n.td,{children:"Goal-Feedback-Result"}),(0,t.jsx)(n.td,{children:"High"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Long-running tasks, behaviors"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-humanoid-robotics-examples-1",children:"Real-world Humanoid Robotics Examples"}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics applications, actions are invaluable for complex tasks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Walking locomotion"}),": A client sets a walking goal with target distance and speed, receiving continuous feedback about step count, balance status, and position"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arm manipulation"}),": A client sends a grasping goal for a specific object, getting feedback about the gripper position, force sensors, and grasp probability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Navigation"}),": A client requests a path to a destination, receiving continuous updates about the robot's location, path progress, and obstacle detection"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"action-architecture",children:"Action Architecture"}),"\n",(0,t.jsx)(n.p,{children:"The action architecture consists of:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Client"}),": Sends goals, receives feedback and results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Server"}),": Processes goals, sends feedback, returns results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Interface"}),": Defines goal, feedback, and result message types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Middleware"}),": Manages the communication between client and server"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"section-4-creating-action-servers-and-clients-1000-words",children:"Section 4: Creating Action Servers and Clients (1000 words)"}),"\n",(0,t.jsx)(n.h3,{id:"part-a-action-interfaces",children:"Part A: Action Interfaces"}),"\n",(0,t.jsxs)(n.p,{children:["Action interfaces are defined using ",(0,t.jsx)(n.code,{children:".action"})," files that explicitly declare three message types: goal, result, and feedback. These files follow a strict format with three sections separated by ",(0,t.jsx)(n.code,{children:"---"})," markers. The order is always goal (top), result (middle), and feedback (bottom)."]}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example of a custom action definition ",(0,t.jsx)(n.code,{children:"ExecuteHumanoidWalk.action"})," for controlling humanoid gait:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# Goal: Request to walk to a certain distance\r\nfloat64 target_distance_meters\r\nfloat64 walking_speed_mps\r\nstring gait_type  # 'bipedal', 'quadrupedal', etc.\r\n---\r\n# Result: Final outcome of the walking task\r\nbool success\r\nstring message\r\nfloat64 actual_distance_moved\r\nint32 steps_taken\r\nbool balance_maintained\r\n---\r\n# Feedback: Continuous updates during walking\r\nfloat64 distance_traveled\r\nfloat64 estimated_remaining_time\r\nfloat64 balance_score\r\nint32 steps_completed\r\nstring current_phase  # 'swing', 'stance', 'transition'\n"})}),"\n",(0,t.jsx)(n.p,{children:"This action interface defines a walking task where a client sets a target distance and speed, receives continuous feedback about the robot's progress, and gets a final result with success status and statistics."}),"\n",(0,t.jsx)(n.h3,{id:"part-b-creating-an-action-server",children:"Part B: Creating an Action Server"}),"\n",(0,t.jsxs)(n.p,{children:["Creating an action server involves inheriting from Node and implementing the action server using the ",(0,t.jsx)(n.code,{children:"rclpy.action"})," interfaces. Here's a detailed implementation of the humanoid walking action server:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\r\nfrom rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\r\nimport time\r\nimport threading\r\nfrom math import sqrt\r\n\r\n# Assuming our custom action type\r\nfrom humanoid_locomotion_interfaces.action import ExecuteHumanoidWalk\r\n\r\n\r\nclass HumanoidWalkActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('humanoid_walk_action_server')\r\n\r\n        # Create action server with callback group to handle multiple goals\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ExecuteHumanoidWalk,\r\n            'execute_humanoid_walk',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback,\r\n            callback_group=MutuallyExclusiveCallbackGroup()\r\n        )\r\n\r\n        self.get_logger().info('Humanoid walk action server is ready.')\r\n\r\n    def goal_callback(self, goal_request):\r\n        \"\"\"Accept or reject a goal.\"\"\"\r\n        self.get_logger().info(\r\n            f'Received walk goal: distance={goal_request.target_distance_meters}, '\r\n            f'speed={goal_request.walking_speed_mps}, gait={goal_request.gait_type}'\r\n        )\r\n\r\n        # Validate the goal parameters\r\n        if goal_request.target_distance_meters <= 0:\r\n            self.get_logger().warn('Invalid target distance - rejecting goal')\r\n            return GoalResponse.REJECT\r\n\r\n        if goal_request.walking_speed_mps <= 0:\r\n            self.get_logger().warn('Invalid walking speed - rejecting goal')\r\n            return GoalResponse.REJECT\r\n\r\n        # Accept the goal\r\n        return GoalResponse.ACCEPT\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        \"\"\"Accept or reject a cancellation request.\"\"\"\r\n        self.get_logger().info('Received request to cancel walk goal')\r\n        return CancelResponse.ACCEPT\r\n\r\n    async def execute_callback(self, goal_handle):\r\n        \"\"\"Execute the goal and return the result.\"\"\"\r\n        self.get_logger().info('Executing walk goal...')\r\n\r\n        # Get the goal request\r\n        goal = goal_handle.request\r\n        target_distance = goal.target_distance_meters\r\n        walking_speed = goal.walking_speed_mps\r\n\r\n        # Initialize feedback and result\r\n        feedback_msg = ExecuteHumanoidWalk.Feedback()\r\n        result_msg = ExecuteHumanoidWalk.Result()\r\n\r\n        # Calculate estimated time\r\n        estimated_time = target_distance / walking_speed\r\n        estimated_remaining_time = estimated_time\r\n        start_time = time.time()\r\n        distance_traveled = 0.0\r\n        steps_taken = 0\r\n        steps_completed = 0\r\n\r\n        # Main walking execution loop\r\n        while distance_traveled < target_distance:\r\n            # Check if the goal was canceled\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                result_msg.success = False\r\n                result_msg.message = 'Goal was canceled'\r\n                result_msg.actual_distance_moved = distance_traveled\r\n                result_msg.steps_taken = steps_taken\r\n                result_msg.balance_maintained = False\r\n                self.get_logger().info('Walk goal canceled')\r\n                return result_msg\r\n\r\n            # Simulate walking progress\r\n            # In a real implementation, this would involve actual robot control\r\n            elapsed = time.time() - start_time\r\n            distance_traveled = min(target_distance, walking_speed * elapsed)\r\n\r\n            # Calculate remaining time based on current progress\r\n            estimated_remaining_time = max(0.0, estimated_time - elapsed)\r\n\r\n            # Update steps taken (simulated - in reality this would come from sensors)\r\n            steps_taken = int(distance_traveled / 0.5)  # Assume 0.5m per step\r\n            steps_completed = steps_taken\r\n\r\n            # Simulate balance score (0.0 to 1.0, with 1.0 being perfect balance)\r\n            balance_score = 0.8 + 0.2 * (distance_traveled / target_distance)\r\n\r\n            # Update feedback message\r\n            feedback_msg.distance_traveled = distance_traveled\r\n            feedback_msg.estimated_remaining_time = estimated_remaining_time\r\n            feedback_msg.balance_score = balance_score\r\n            feedback_msg.steps_completed = steps_completed\r\n\r\n            # Determine current phase (this is simplified, real implementation would be more complex)\r\n            if steps_completed % 3 == 0:\r\n                feedback_msg.current_phase = 'stance'\r\n            elif steps_completed % 3 == 1:\r\n                feedback_msg.current_phase = 'swing'\r\n            else:\r\n                feedback_msg.current_phase = 'transition'\r\n\r\n            # Publish feedback\r\n            goal_handle.publish_feedback(feedback_msg)\r\n\r\n            self.get_logger().info(\r\n                f'Walking progress: {distance_traveled:.2f}m / {target_distance:.2f}m '\r\n                f'(phase: {feedback_msg.current_phase}, balance: {balance_score:.2f})'\r\n            )\r\n\r\n            # Sleep to simulate the time it takes for the robot to take steps\r\n            time.sleep(0.5)\r\n\r\n            # Small chance of balance loss (simulated)\r\n            if balance_score < 0.3:\r\n                goal_handle.abort()\r\n                result_msg.success = False\r\n                result_msg.message = 'Balance lost during walking'\r\n                result_msg.actual_distance_moved = distance_traveled\r\n                result_msg.steps_taken = steps_taken\r\n                result_msg.balance_maintained = False\r\n                self.get_logger().error('Aborting walk due to balance loss')\r\n                return result_msg\r\n\r\n        # Goal completed successfully\r\n        if not goal_handle.is_cancel_requested:\r\n            goal_handle.succeed()\r\n            result_msg.success = True\r\n            result_msg.message = f'Walk completed successfully. Traveled {distance_traveled:.2f} meters.'\r\n            result_msg.actual_distance_moved = distance_traveled\r\n            result_msg.steps_taken = steps_taken\r\n            result_msg.balance_maintained = True\r\n            self.get_logger().info(f'Walk goal succeeded: traveled {distance_traveled:.2f}m')\r\n\r\n        return result_msg\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    walk_server = HumanoidWalkActionServer()\r\n\r\n    try:\r\n        # Use a multi-threaded executor to handle multiple goals if needed\r\n        executor = MultiThreadedExecutor(num_threads=4)\r\n        rclpy.spin(walk_server, executor=executor)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        walk_server.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"This action server demonstrates:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Goal validation and acceptance/rejection"}),"\n",(0,t.jsx)(n.li,{children:"Proper state management and cancellation handling"}),"\n",(0,t.jsx)(n.li,{children:"Continuous feedback publishing during execution"}),"\n",(0,t.jsx)(n.li,{children:"Final result generation when the task completes"}),"\n",(0,t.jsx)(n.li,{children:"Thread-safe implementation for handling multiple goals"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"part-c-creating-an-action-client",children:"Part C: Creating an Action Client"}),"\n",(0,t.jsx)(n.p,{children:"Action clients send goals to action servers and monitor progress. Here's an implementation of an action client for the walking action:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\nfrom rclpy.duration import Duration\r\n\r\n# Assuming our custom action type\r\nfrom humanoid_locomotion_interfaces.action import ExecuteHumanoidWalk\r\n\r\n\r\nclass HumanoidWalkActionClient(Node):\r\n    def __init__(self):\r\n        super().__init__('humanoid_walk_action_client')\r\n\r\n        # Create action client\r\n        self._action_client = ActionClient(\r\n            self,\r\n            ExecuteHumanoidWalk,\r\n            'execute_humanoid_walk'\r\n        )\r\n\r\n    def send_goal(self, target_distance, walking_speed, gait_type='bipedal'):\r\n        \"\"\"Send a goal to the action server.\"\"\"\r\n        # Wait for the action server to be available\r\n        self.get_logger().info('Waiting for action server...')\r\n        self._action_client.wait_for_server()\r\n\r\n        # Create the goal message\r\n        goal_msg = ExecuteHumanoidWalk.Goal()\r\n        goal_msg.target_distance_meters = target_distance\r\n        goal_msg.walking_speed_mps = walking_speed\r\n        goal_msg.gait_type = gait_type\r\n\r\n        self.get_logger().info(\r\n            f'Sending walk goal: {target_distance}m at {walking_speed} m/s using {gait_type} gait'\r\n        )\r\n\r\n        # Send the goal and register callbacks for feedback and result\r\n        self._send_goal_future = self._action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback\r\n        )\r\n\r\n        # Register callback for when the result is received\r\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\r\n\r\n        return self._send_goal_future\r\n\r\n    def goal_response_callback(self, future):\r\n        \"\"\"Handle the result of sending the goal.\"\"\"\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info('Goal rejected by server')\r\n            return\r\n\r\n        self.get_logger().info('Goal accepted by server, waiting for result...')\r\n\r\n        # Get the result asynchronously\r\n        self._get_result_future = goal_handle.get_result_async()\r\n        self._get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        \"\"\"Handle feedback from the action server.\"\"\"\r\n        self.get_logger().info(\r\n            f'Received feedback: Traveled {feedback_msg.distance_traveled:.2f}m, '\r\n            f'Remaining: {feedback_msg.estimated_remaining_time:.2f}s, '\r\n            f'Balance: {feedback_msg.balance_score:.2f}, '\r\n            f'Phase: {feedback_msg.current_phase}'\r\n        )\r\n\r\n    def get_result_callback(self, future):\r\n        \"\"\"Handle the final result from the action server.\"\"\"\r\n        result = future.result().result\r\n        self.get_logger().info(f'Result received: {result.message}')\r\n\r\n        if result.success:\r\n            self.get_logger().info(\r\n                f'Successfully moved {result.actual_distance_moved:.2f} meters '\r\n                f'in {result.steps_taken} steps with maintained balance: {result.balance_maintained}'\r\n            )\r\n        else:\r\n            self.get_logger().info('Walk action did not complete successfully')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    walk_client = HumanoidWalkActionClient()\r\n\r\n    # Send a goal to walk 3 meters at 0.5 m/s using bipedal gait\r\n    future = walk_client.send_goal(3.0, 0.5, 'bipedal')\r\n\r\n    try:\r\n        # Spin to process callbacks\r\n        rclpy.spin(walk_client)\r\n    except KeyboardInterrupt:\r\n        walk_client.get_logger().info('Interrupted during action execution')\r\n    finally:\r\n        walk_client.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:"This action client demonstrates:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Asynchronous goal sending with proper callbacks"}),"\n",(0,t.jsx)(n.li,{children:"Feedback handling during execution"}),"\n",(0,t.jsx)(n.li,{children:"Result handling when the action completes"}),"\n",(0,t.jsx)(n.li,{children:"Proper client lifecycle management"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"section-5-practical-comparison-and-use-cases-600-words",children:"Section 5: Practical Comparison and Use Cases (600 words)"}),"\n",(0,t.jsx)(n.p,{children:"Understanding when to use topics, services, or actions is crucial for effective ROS 2 design. Each communication pattern serves different purposes and has distinct characteristics that make it suitable for specific use cases."}),"\n",(0,t.jsx)(n.h3,{id:"decision-framework-for-communication-patterns",children:"Decision Framework for Communication Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Use this framework to select the appropriate communication pattern:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": For streaming data, sensor feeds, and status updates where immediate response isn't needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": For simple, synchronous request-response interactions that complete quickly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": For long-running tasks that require feedback, monitoring, and potential cancellation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"comprehensive-comparison",children:"Comprehensive Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Topics"}),(0,t.jsx)(n.th,{children:"Services"}),(0,t.jsx)(n.th,{children:"Actions"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Purpose"})}),(0,t.jsx)(n.td,{children:"Streaming data"}),(0,t.jsx)(n.td,{children:"Request-response"}),(0,t.jsx)(n.td,{children:"Long-running tasks with feedback"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Synchronicity"})}),(0,t.jsx)(n.td,{children:"Asynchronous"}),(0,t.jsx)(n.td,{children:"Synchronous"}),(0,t.jsx)(n.td,{children:"Semi-synchronous"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Response Guarantee"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Yes (final result)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Feedback"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes (continuous)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Cancellation"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Use Duration"})}),(0,t.jsx)(n.td,{children:"Continuous"}),(0,t.jsx)(n.td,{children:"Short-term"}),(0,t.jsx)(n.td,{children:"Long-term"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Communication Type"})}),(0,t.jsx)(n.td,{children:"One-way"}),(0,t.jsx)(n.td,{children:"Two-way"}),(0,t.jsx)(n.td,{children:"Goal-oriented"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"State Tracking"})}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Yes (full state machine)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-robotics-use-cases",children:"Real-World Robotics Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"In humanoid robotics applications, selecting the right communication pattern is essential for effective robot control:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Topics Use Cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Publishing sensor data (IMU readings, camera feeds, joint positions)"}),"\n",(0,t.jsx)(n.li,{children:"Broadcasting robot state (current mode, battery level, active errors)"}),"\n",(0,t.jsx)(n.li,{children:"Publishing control commands for joint controllers"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Services Use Cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Querying robot parameters (current joint limits, operational modes)"}),"\n",(0,t.jsx)(n.li,{children:"Triggering immediate actions (emergency stop, zeroing joint encoders)"}),"\n",(0,t.jsx)(n.li,{children:"Configuration changes (updating robot mode, setting calibration)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Actions Use Cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Navigation to waypoints (with continuous pose feedback)"}),"\n",(0,t.jsx)(n.li,{children:"Manipulation tasks (with continuous gripper state feedback)"}),"\n",(0,t.jsx)(n.li,{children:"Walking locomotion (with continuous balance and step feedback)"}),"\n",(0,t.jsx)(n.li,{children:"Complex multi-step behaviors (with continuous progress feedback)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Highest frequency/lowest latency, best for continuous data streams"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Moderate frequency/latency, good for configuration and queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Lower frequency/higher latency, necessary for long-running tasks"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Often, robot systems combine multiple communication patterns. For example, a navigation system might use:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"})," for continuous odometry and sensor data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"})," for setting navigation goals or querying robot status"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"})," for executing complex navigation tasks with progress feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This multi-pattern approach allows for robust, responsive robot systems that can handle various types of interactions effectively."}),"\n",(0,t.jsx)(n.h2,{id:"summary-and-next-steps-200-words",children:"Summary and Next Steps (200 words)"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we've explored the synchronous communication patterns of ROS 2: services and actions. You've learned how services facilitate request-response interactions for immediate queries and configurations, and how actions manage long-running tasks with continuous feedback and cancellation capabilities."}),"\n",(0,t.jsxs)(n.p,{children:["We covered service interfaces defined in ",(0,t.jsx)(n.code,{children:".srv"})," files and implemented both service servers and clients with proper error handling. We examined action interfaces with their goal-feedback-result structure and built comprehensive action servers and clients with state management and feedback handling."]}),"\n",(0,t.jsx)(n.p,{children:"The comparison of topics vs services vs actions provides a clear decision framework for selecting the appropriate communication pattern based on your specific robotics application needs. Whether you're requesting immediate robot status (service) or commanding a long navigation task with progress feedback (action), you now have the knowledge to implement the correct pattern."}),"\n",(0,t.jsx)(n.p,{children:"In the next chapter, we'll explore advanced ROS 2 concepts including Quality of Service settings, composition for efficient process management, and lifecycle nodes for complex system management. These advanced topics will further enhance your ability to design robust, scalable robotic systems."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);