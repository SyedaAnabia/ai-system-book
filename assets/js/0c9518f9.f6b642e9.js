"use strict";(globalThis.webpackChunkai_systems_book=globalThis.webpackChunkai_systems_book||[]).push([[402],{3721:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module1/chapter4-params-launch","title":"ROS 2 Parameters and Launch Files - Configuration and Orchestration","description":"Learning Objectives","source":"@site/docs/module1/chapter4-params-launch.md","sourceDirName":"module1","slug":"/module1/chapter4-params-launch","permalink":"/ai-system-book/module1/chapter4-params-launch","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedaAnabia/ai-systems-book/docs/module1/chapter4-params-launch.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Services and Actions - Request-Response Communication","permalink":"/ai-system-book/module1/chapter3-services-actions"},"next":{"title":"Overview of Digital Twin Technology and its Importance in Robotics","permalink":"/ai-system-book/module2/chapter1-overview"}}');var i=r(4848),t=r(8453);const o={},s="ROS 2 Parameters and Launch Files - Configuration and Orchestration",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"1. Understanding ROS 2 Parameters",id:"1-understanding-ros-2-parameters",level:2},{value:"1.1 What are Parameters?",id:"11-what-are-parameters",level:3},{value:"1.2 Parameter Types and Constraints",id:"12-parameter-types-and-constraints",level:3},{value:"1.3 Creating Your First Parameter Node",id:"13-creating-your-first-parameter-node",level:3},{value:"2. Working with Parameters in Depth",id:"2-working-with-parameters-in-depth",level:2},{value:"2.1 Parameter Callbacks and Validation",id:"21-parameter-callbacks-and-validation",level:3},{value:"2.2 YAML Configuration Files",id:"22-yaml-configuration-files",level:3},{value:"2.3 Command-Line Parameter Setting",id:"23-command-line-parameter-setting",level:3},{value:"3. Introduction to Launch Files",id:"3-introduction-to-launch-files",level:2},{value:"3.1 Why Launch Files Matter",id:"31-why-launch-files-matter",level:3},{value:"3.2 Launch File Formats",id:"32-launch-file-formats",level:3},{value:"3.3 Basic Launch File Structure",id:"33-basic-launch-file-structure",level:3},{value:"4. Creating Launch Files",id:"4-creating-launch-files",level:2},{value:"4.1 Python Launch API Fundamentals",id:"41-python-launch-api-fundamentals",level:3},{value:"4.2 Launching Single and Multiple Nodes",id:"42-launching-single-and-multiple-nodes",level:3},{value:"4.3 Node Remapping and Namespacing",id:"43-node-remapping-and-namespacing",level:3},{value:"5. Advanced Launch Techniques",id:"5-advanced-launch-techniques",level:2},{value:"5.1 Conditional Launching (if/unless)",id:"51-conditional-launching-ifunless",level:3},{value:"5.2 Launch File Composition Patterns",id:"52-launch-file-composition-patterns",level:3},{value:"6. Quality of Service (QoS) Profiles",id:"6-quality-of-service-qos-profiles",level:2},{value:"6.1 QoS Profiles Explained",id:"61-qos-profiles-explained",level:3},{value:"7. Practical Example: Humanoid Robot System",id:"7-practical-example-humanoid-robot-system",level:2},{value:"8. Debugging and Tools",id:"8-debugging-and-tools",level:2},{value:"8.1 ROS 2 CLI Tools for Parameters and Launch",id:"81-ros-2-cli-tools-for-parameters-and-launch",level:3},{value:"8.2 Visualization and Monitoring",id:"82-visualization-and-monitoring",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Basic Parameter Configuration (Beginner)",id:"exercise-1-basic-parameter-configuration-beginner",level:3},{value:"Exercise 2: Multi-Node Launch System (Intermediate)",id:"exercise-2-multi-node-launch-system-intermediate",level:3},{value:"Exercise 3: Advanced Parameter Validation (Advanced)",id:"exercise-3-advanced-parameter-validation-advanced",level:3},{value:"Summary and Next Steps",id:"summary-and-next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2},{value:"FAQ",id:"faq",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-parameters-and-launch-files---configuration-and-orchestration",children:"ROS 2 Parameters and Launch Files - Configuration and Orchestration"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the purpose of ROS 2 parameters and how they differ from hard-coded values"}),"\n",(0,i.jsx)(n.li,{children:"Implement parameter declarations, access, and validation in ROS 2 nodes"}),"\n",(0,i.jsx)(n.li,{children:"Create and manage launch files for orchestrating multi-node robotic systems"}),"\n",(0,i.jsx)(n.li,{children:"Use launch file arguments and substitutions for flexible deployments"}),"\n",(0,i.jsx)(n.li,{children:"Apply Quality of Service (QoS) profiles appropriately for different communication needs"}),"\n",(0,i.jsx)(n.li,{children:"Debug and troubleshoot parameter and launch file configurations"}),"\n",(0,i.jsx)(n.li,{children:"Design humanoid robot systems using proper parameter management and orchestration"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before starting this chapter, you should have:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Completed Chapters 1-3 of this book (ROS 2 basics, topics, services/actions)"}),"\n",(0,i.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,i.jsx)(n.li,{children:"ROS 2 Iron or Humble installed and properly configured"}),"\n",(0,i.jsx)(n.li,{children:"Comfort with command-line interfaces"}),"\n",(0,i.jsx)(n.li,{children:"Understanding of robot simulation environments (Gazebo/RViz2)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"1-understanding-ros-2-parameters",children:"1. Understanding ROS 2 Parameters"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 parameters provide a way to configure nodes at runtime without recompiling code. They enable dynamic reconfiguration of node behavior and facilitate system adaptation to different environments or operational modes. This is particularly important in humanoid robotics where robots may need to adjust their behavior based on environmental conditions or operational requirements."}),"\n",(0,i.jsx)(n.h3,{id:"11-what-are-parameters",children:"1.1 What are Parameters?"}),"\n",(0,i.jsx)(n.p,{children:"Parameters in ROS 2 are named values that belong to a specific node. They can be:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Set at node startup via launch files or parameter files"}),"\n",(0,i.jsx)(n.li,{children:"Modified at runtime through command-line tools or other nodes"}),"\n",(0,i.jsx)(n.li,{children:"Bound to specific types and ranges for validation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Parameters differ from topics in that they provide a key-value store rather than a communication channel. They differ from services in that they don't require request-response patterns but instead provide persistent state that can be changed dynamically."}),"\n",(0,i.jsx)(n.h3,{id:"12-parameter-types-and-constraints",children:"1.2 Parameter Types and Constraints"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 supports several parameter types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Integer (int64)"}),"\n",(0,i.jsx)(n.li,{children:"Double (float64)"}),"\n",(0,i.jsx)(n.li,{children:"String"}),"\n",(0,i.jsx)(n.li,{children:"Boolean"}),"\n",(0,i.jsx)(n.li,{children:"Lists (integer, double, string, boolean)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Parameters can include constraints to ensure valid values:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Integer/double ranges"}),"\n",(0,i.jsx)(n.li,{children:"Allowed string values"}),"\n",(0,i.jsx)(n.li,{children:"Read-only parameters"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic validation through callbacks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"13-creating-your-first-parameter-node",children:"1.3 Creating Your First Parameter Node"}),"\n",(0,i.jsx)(n.p,{children:"Let's start with a simple node that declares and uses parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# File: simple_parameter_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.parameter import Parameter\r\nfrom rclpy.exceptions import ParameterNotDeclaredException\r\n\r\n\r\nclass SimpleParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_parameter_node')\r\n        \r\n        # Declare parameters with default values and descriptions\r\n        self.declare_parameter(\r\n            'robot_name', \r\n            'default_robot',\r\n            ParameterDescriptor(description='Name of the robot')\r\n        )\r\n        \r\n        self.declare_parameter(\r\n            'operational_mode', \r\n            'normal',\r\n            ParameterDescriptor(\r\n                description='Operating mode of the robot',\r\n                type_=ParameterType.PARAMETER_STRING\r\n            )\r\n        )\r\n        \r\n        self.declare_parameter(\r\n            'max_velocity', \r\n            1.0,\r\n            ParameterDescriptor(\r\n                description='Maximum velocity for movement',\r\n                type_=ParameterType.PARAMETER_DOUBLE,\r\n                floating_point_range=[FloatingPointRange(from_value=0.1, to_value=10.0, step=0.1)]\r\n            )\r\n        )\r\n\r\n        # Get parameter values\r\n        robot_name = self.get_parameter('robot_name').value\r\n        operational_mode = self.get_parameter('operational_mode').value\r\n        max_velocity = self.get_parameter('max_velocity').value\r\n\r\n        self.get_logger().info(f'Robot name: {robot_name}')\r\n        self.get_logger().info(f'Operational mode: {operational_mode}')\r\n        self.get_logger().info(f'Max velocity: {max_velocity}')\r\n\r\n        # Create a parameter callback to handle dynamic changes\r\n        self.add_on_set_parameters_callback(self.parameter_callback)\r\n\r\n    def parameter_callback(self, params):\r\n        \"\"\"Handle parameter changes.\"\"\"\r\n        for param in params:\r\n            if param.name == 'max_velocity':\r\n                if param.value > 5.0:\r\n                    self.get_logger().warn(f'Velocity {param.value} may be unsafe for humanoids')\r\n        return SetParametersResult(successful=True)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    simple_param_node = SimpleParameterNode()\r\n    \r\n    try:\r\n        rclpy.spin(simple_param_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        simple_param_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-working-with-parameters-in-depth",children:"2. Working with Parameters in Depth"}),"\n",(0,i.jsx)(n.h3,{id:"21-parameter-callbacks-and-validation",children:"2.1 Parameter Callbacks and Validation"}),"\n",(0,i.jsx)(n.p,{children:"Parameter callbacks allow nodes to validate incoming parameter changes and react to them appropriately. This is essential for humanoid robotics where safety and operational constraints must be maintained."}),"\n",(0,i.jsx)(n.h3,{id:"22-yaml-configuration-files",children:"2.2 YAML Configuration Files"}),"\n",(0,i.jsx)(n.p,{children:"Parameters can be loaded from YAML files, which is more convenient for complex systems:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# robot_params.yaml\r\n/**:\r\n  ros__parameters:\r\n    robot_name: "humanoid_alpha"\r\n    operational_mode: "cautious"\r\n    max_velocity: 2.0\r\n    joint_limits:\r\n      hip_pitch_min: -0.5\r\n      hip_pitch_max: 1.0\r\n      knee_pitch_min: 0.0\r\n      knee_pitch_max: 2.0\n'})}),"\n",(0,i.jsx)(n.h3,{id:"23-command-line-parameter-setting",children:"2.3 Command-Line Parameter Setting"}),"\n",(0,i.jsx)(n.p,{children:"You can also set parameters from the command line:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Set a parameter for a running node\r\nros2 param set /simple_parameter_node robot_name "advanced_robot"\r\n\r\n# Get a parameter value\r\nros2 param get /simple_parameter_node max_velocity\r\n\r\n# List all parameters for a node\r\nros2 param list /simple_parameter_node\n'})}),"\n",(0,i.jsx)(n.h2,{id:"3-introduction-to-launch-files",children:"3. Introduction to Launch Files"}),"\n",(0,i.jsx)(n.p,{children:"Launch files provide a way to start multiple nodes at once, configure them, and manage their lifecycle. For humanoid robots, which typically consist of many interconnected nodes, launch files are essential for coordinated startup and configuration."}),"\n",(0,i.jsx)(n.h3,{id:"31-why-launch-files-matter",children:"3.1 Why Launch Files Matter"}),"\n",(0,i.jsx)(n.p,{children:"Without launch files, starting a complex robotic system would require manually opening multiple terminals and running commands sequentially. Launch files automate this process, ensuring proper startup order and configuration."}),"\n",(0,i.jsx)(n.h3,{id:"32-launch-file-formats",children:"3.2 Launch File Formats"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 supports multiple launch file formats:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Python (recommended): Most flexible, supports complex logic"}),"\n",(0,i.jsx)(n.li,{children:"XML: Declarative, but less flexible"}),"\n",(0,i.jsx)(n.li,{children:"YAML: Declarative, but limited functionality"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"33-basic-launch-file-structure",children:"3.3 Basic Launch File Structure"}),"\n",(0,i.jsx)(n.p,{children:"Here's a basic launch file structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# basic_launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='my_robot_package',\r\n            executable='simple_parameter_node',\r\n            name='robot_controller',\r\n            parameters=[\r\n                {'robot_name': 'launch_robot'},\r\n                {'operational_mode': 'demo'},\r\n                {'max_velocity': 1.5}\r\n            ],\r\n            output='screen'\r\n        )\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"4-creating-launch-files",children:"4. Creating Launch Files"}),"\n",(0,i.jsx)(n.h3,{id:"41-python-launch-api-fundamentals",children:"4.1 Python Launch API Fundamentals"}),"\n",(0,i.jsx)(n.p,{children:"The Python launch API provides the most flexibility for creating complex launch scenarios. It allows for conditional execution, argument passing, and dynamic node creation."}),"\n",(0,i.jsx)(n.h3,{id:"42-launching-single-and-multiple-nodes",children:"4.2 Launching Single and Multiple Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Launch files can start single nodes or complex multi-node systems:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# multi_node_launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\n\r\n\r\ndef generate_launch_description():\r\n    # Declare launch arguments\r\n    robot_namespace = LaunchConfiguration('robot_namespace')\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n    \r\n    return LaunchDescription([\r\n        # Declare launch arguments\r\n        DeclareLaunchArgument(\r\n            'robot_namespace',\r\n            default_value='robot1',\r\n            description='Robot namespace'\r\n        ),\r\n        DeclareLaunchArgument(\r\n            'use_sim_time',\r\n            default_value='false',\r\n            description='Use simulation time'\r\n        ),\r\n        \r\n        # Robot controller node\r\n        Node(\r\n            package='my_robot_package',\r\n            executable='robot_controller',\r\n            name='controller',\r\n            namespace=robot_namespace,\r\n            parameters=[\r\n                {'use_sim_time': use_sim_time},\r\n                # More parameters here\r\n            ],\r\n            remappings=[\r\n                ('/cmd_vel', 'cmd_vel'),\r\n                ('/odom', 'odom'),\r\n            ]\r\n        ),\r\n        \r\n        # Sensor processor node\r\n        Node(\r\n            package='my_robot_package',\r\n            executable='sensor_processor',\r\n            name='sensors',\r\n            namespace=robot_namespace,\r\n            parameters=[\r\n                {'use_sim_time': use_sim_time},\r\n                # More parameters here\r\n            ]\r\n        )\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"43-node-remapping-and-namespacing",children:"4.3 Node Remapping and Namespacing"}),"\n",(0,i.jsx)(n.p,{children:"Launch files support remapping topics and namespacing nodes, which is crucial for multi-robot systems and avoiding naming conflicts."}),"\n",(0,i.jsx)(n.h2,{id:"5-advanced-launch-techniques",children:"5. Advanced Launch Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"51-conditional-launching-ifunless",children:"5.1 Conditional Launching (if/unless)"}),"\n",(0,i.jsx)(n.p,{children:"Launch files can conditionally start nodes based on arguments or other conditions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# conditional_launch.py\r\nfrom launch import LaunchDescription, LaunchCondition\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.conditions import IfCondition\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\n\r\n\r\ndef generate_launch_description():\r\n    debug_enabled = LaunchConfiguration('debug')\r\n    \r\n    return LaunchDescription([\r\n        DeclareLaunchArgument(\r\n            'debug',\r\n            default_value='false',\r\n            description='Enable debug nodes'\r\n        ),\r\n        \r\n        # Debug node that only runs if debug is enabled\r\n        Node(\r\n            package='rqt_graph',\r\n            executable='rqt_graph',\r\n            condition=IfCondition(debug_enabled)\r\n        )\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"52-launch-file-composition-patterns",children:"5.2 Launch File Composition Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Complex systems often use composition patterns to include other launch files:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# main_launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import PathJoinSubstitution\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        # Include other launch files\r\n        IncludeLaunchDescription(\r\n            PythonLaunchDescriptionSource(\r\n                PathJoinSubstitution([\r\n                    FindPackageShare('my_robot_description'),\r\n                    'launch',\r\n                    'robot_description.launch.py'\r\n                ])\r\n            )\r\n        ),\r\n        \r\n        IncludeLaunchDescription(\r\n            PythonLaunchDescriptionSource(\r\n                PathJoinSubstitution([\r\n                    FindPackageShare('my_robot_control'),\r\n                    'launch',\r\n                    'controllers.launch.py'\r\n                ])\r\n            )\r\n        )\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"6-quality-of-service-qos-profiles",children:"6. Quality of Service (QoS) Profiles"}),"\n",(0,i.jsx)(n.p,{children:"QoS profiles control how messages are delivered between nodes. For humanoid robotics applications where safety and real-time performance are critical, choosing appropriate QoS settings is essential."}),"\n",(0,i.jsx)(n.h3,{id:"61-qos-profiles-explained",children:"6.1 QoS Profiles Explained"}),"\n",(0,i.jsx)(n.p,{children:"Different QoS profiles provide different guarantees for reliability, durability, and history of messages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reliability"}),": Whether messages are guaranteed to be delivered"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Durability"}),": Whether late-joining subscribers receive previous messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"History"}),": How many messages to store for delivery"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"7-practical-example-humanoid-robot-system",children:"7. Practical Example: Humanoid Robot System"}),"\n",(0,i.jsx)(n.p,{children:"Let's put everything together with a practical example of a humanoid robot system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# humanoid_system_launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, RegisterEventHandler\r\nfrom launch.event_handlers import OnProcessStart\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node, ComposableNodeContainer\r\nfrom launch_ros.descriptions import ComposableNode\r\n\r\n\r\ndef generate_launch_description():\r\n    # Launch arguments\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n    robot_config = LaunchConfiguration('robot_config')\r\n    \r\n    # Composable nodes container for efficiency\r\n    perception_container = ComposableNodeContainer(\r\n        name='perception_container',\r\n        namespace='',\r\n        package='rclcpp_components',\r\n        executable='component_container',\r\n        composable_node_descriptions=[\r\n            ComposableNode(\r\n                package='image_proc',\r\n                plugin='image_proc::RectifyNode',\r\n                name='rectify_node'\r\n            ),\r\n            ComposableNode(\r\n                package='depth_image_proc',\r\n                plugin='depth_image_proc::PointCloudXyzrgbNode',\r\n                name='pointcloud_node'\r\n            )\r\n        ],\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen'\r\n    )\r\n    \r\n    return LaunchDescription([\r\n        DeclareLaunchArgument(\r\n            'use_sim_time',\r\n            default_value='false',\r\n            description='Use simulation time'\r\n        ),\r\n        DeclareLaunchArgument(\r\n            'robot_config',\r\n            default_value='config/default.yaml',\r\n            description='Robot configuration file'\r\n        ),\r\n        \r\n        # Robot state publisher with parameters\r\n        Node(\r\n            package='robot_state_publisher',\r\n            executable='robot_state_publisher',\r\n            parameters=[\r\n                robot_config,\r\n                {'use_sim_time': use_sim_time}\r\n            ]\r\n        ),\r\n        \r\n        # Joint state broadcaster\r\n        Node(\r\n            package='joint_state_broadcaster',\r\n            executable='joint_state_broadcaster',\r\n            parameters=[{'use_sim_time': use_sim_time}]\r\n        ),\r\n        \r\n        # Perception container\r\n        perception_container,\r\n        \r\n        # Main controller with parameter validation\r\n        Node(\r\n            package='humanoid_controller',\r\n            executable='main_controller',\r\n            parameters=[\r\n                robot_config,\r\n                {'use_sim_time': use_sim_time}\r\n            ],\r\n            on_exit=RegisterEventHandler(\r\n                OnProcessStart(\r\n                    target_action=perception_container,\r\n                    on_start=lambda event: print(\"Controller started after perception container\")\r\n                )\r\n            )\r\n        )\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"8-debugging-and-tools",children:"8. Debugging and Tools"}),"\n",(0,i.jsx)(n.h3,{id:"81-ros-2-cli-tools-for-parameters-and-launch",children:"8.1 ROS 2 CLI Tools for Parameters and Launch"}),"\n",(0,i.jsx)(n.p,{children:"Several command-line tools help with debugging parameters and launches:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# List all parameters for a node\r\nros2 param list /node_name\r\n\r\n# Get parameter value\r\nros2 param get /node_name param_name\r\n\r\n# Set parameter value\r\nros2 param set /node_name param_name new_value\r\n\r\n# List all available launch files in a package\r\nros2 launch <package_name>\r\n\r\n# Run a launch file\r\nros2 launch <package_name> <launch_file.py>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"82-visualization-and-monitoring",children:"8.2 Visualization and Monitoring"}),"\n",(0,i.jsxs)(n.p,{children:["Tools like ",(0,i.jsx)(n.code,{children:"rqt_reconfigure"})," allow real-time parameter adjustment, while ",(0,i.jsx)(n.code,{children:"rqt_graph"})," visualizes the node graph structure of your system."]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-basic-parameter-configuration-beginner",children:"Exercise 1: Basic Parameter Configuration (Beginner)"}),"\n",(0,i.jsx)(n.p,{children:"Create a simple node that accepts a robot configuration parameter and adjusts its behavior accordingly. Test changing the parameter at runtime."}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-multi-node-launch-system-intermediate",children:"Exercise 2: Multi-Node Launch System (Intermediate)"}),"\n",(0,i.jsx)(n.p,{children:"Design a launch file that starts multiple nodes representing a basic humanoid robot (e.g., controller, sensors, and visualization) with proper parameter configuration and namespacing."}),"\n",(0,i.jsx)(n.h3,{id:"exercise-3-advanced-parameter-validation-advanced",children:"Exercise 3: Advanced Parameter Validation (Advanced)"}),"\n",(0,i.jsx)(n.p,{children:"Create a node with complex parameter validation that prevents unsafe configuration changes, particularly for humanoid joint limits and velocity constraints."}),"\n",(0,i.jsx)(n.h2,{id:"summary-and-next-steps",children:"Summary and Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered the essential ROS 2 concepts of parameters and launch files that enable configuration management and system orchestration. You learned how to create nodes with dynamic parameters, organize system startup with launch files, and apply these concepts to humanoid robotics systems."}),"\n",(0,i.jsx)(n.p,{children:"In the next chapter, we'll explore advanced ROS 2 concepts including composition, lifecycle nodes, and diagnostics for building production-ready robotic systems."}),"\n",(0,i.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/How-To-Guides/Using-Parameters-In-A-Class-Python.html",children:"ROS 2 Parameters Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Launch-system.html",children:"Launch System Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/ros2/design/blob/master/articles/qos_changes_and_defaults.md",children:"QoS Implementation in RMW"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://index.ros.org/doc/ros2/Releases/Release-Galactic-Geochelone/#parameter-best-practice-guide",children:"Parameter Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://index.ros.org/doc/ros2/Tutorials/Composition/#composition-launch-file",children:"Launch File Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: When should I use parameters vs topics vs services?"}),(0,i.jsx)(n.br,{}),"\n","A: Use parameters for configuration values that change infrequently and need to persist across node restarts. Use topics for continuous data streaming, and services for request-response interactions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: How do I share parameters between nodes?"}),(0,i.jsx)(n.br,{}),"\n","A: Parameters are node-specific by default. To share configuration values, you can use a parameter server node, share parameter files, or use services to query configuration."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: What's the difference between launch files and bringup scripts?"}),(0,i.jsx)(n.br,{}),"\n","A: Launch files are the modern ROS 2 approach using the launch system, while bringup scripts are older shell scripts that manually start nodes. Launch files provide better error handling, parameter configuration, and lifecycle management."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var a=r(6540);const i={},t=a.createContext(i);function o(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);